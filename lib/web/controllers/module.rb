module Web
  module Controllers
    # Controller to handle all routes relating to a specific module.
    class Module < Base
      helpers Web::Helpers::OptionsHelper

      use Rack::PostBodyContentTypeParser

      def inflated_references(references)
        return if references.nil?
        references.map do |ref|
          Wpxf::Utility::ReferenceInflater.new(ref[0]).inflate(ref[1])
        end
      end

      def load_module(type, name)
        class_name = Wpxf.path_to_class_name(name)
        namespace = type.eql?('exploit') ? Wpxf::Exploit : Wpxf::Auxiliary
        return namespace.const_get(class_name).new
      rescue NameError
        return nil
      end

      def load_payload(name)
        class_name = Wpxf.path_to_class_name(name)
        return Wpxf::Payloads.const_get(class_name).new
      rescue NameError
        return nil
      end

      get '/:type/:name' do
        halt unless params['type'].eql?('exploit') || params['type'].eql?('auxiliary')
        mod = load_module(params['type'], params['name'])
        halt 404 if mod.nil?

        json(
          title: mod.module_name,
          desc: mod.module_desc,
          references: inflated_references(mod.module_references),
          authors: mod.module_author,
          date: mod.module_date,
          options: options_hash(mod.options),
          path: "#{params['type']}/#{params['name']}"
        )
      end

      post '/:type/:name' do
        halt unless params['type'].eql?('exploit') || params['type'].eql?('auxiliary')
        mod = load_module(params['type'], params['name'])
        halt 404 if mod.nil?

        params['options'].each do |opt|
          mod.set_option_value(opt['name'], opt['value'])
        end

        unless params['payload'] || params['payload'].empty?
          mod.payload = load_payload(params['payload']['name'])
          params['payload']['options'].each do |opt|
            mod.payload.set_option_value(opt['name'], opt['value'])
          end
        end

        halt 500, { 'Content-Type' => 'application/json' }, json(success: false) unless mod.can_execute?

        session = Web::Models::Session.create(module_path: "#{params['type']}/#{params['name']}")

        listener = Class.new do
          include Cli::TableOutputHelper

          def initialize(session)
            super()
            self.session = session
            self.indent = ''
          end

          def on_event_emitted(event)
            session.events.create(
              message: event[:msg] || "\n" + build_table(event[:rows]),
              level: event[:type],
              verbose: event[:verbose]
            )
          end

          attr_accessor :session
        end.new(session)

        Thread.new do
          mod.event_emitter.subscribe(listener)
          mod.run
        end

        json 'success' => 'true', 'session_id' => session.id
      end
    end
  end
end
