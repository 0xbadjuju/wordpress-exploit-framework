module Web
  module Controllers
    # Controller to handle all routes relating to a specific module.
    class Module < Base
      helpers Web::Helpers::OptionsHelper

      use Rack::PostBodyContentTypeParser

      def inflated_references(references)
        return if references.nil?
        references.map do |ref|
          Wpxf::Utility::ReferenceInflater.new(ref[0]).inflate(ref[1])
        end
      end

      def load_module(type, name)
        class_name = Wpxf.path_to_class_name(name)
        namespace = type.eql?('exploit') ? Wpxf::Exploit : Wpxf::Auxiliary
        return namespace.const_get(class_name).new
      rescue NameError
        return nil
      end

      def load_payload(name)
        class_name = Wpxf.path_to_class_name(name)
        return Wpxf::Payloads.const_get(class_name).new
      rescue NameError
        return nil
      end

      get '/:type/:name' do
        halt unless params['type'].eql?('exploit') || params['type'].eql?('auxiliary')
        mod = load_module(params['type'], params['name'])
        halt 404 if mod.nil?

        json(
          title: mod.module_name,
          desc: mod.module_desc,
          references: inflated_references(mod.module_references),
          authors: mod.module_author,
          date: mod.module_date,
          options: options_hash(mod.options),
          path: "#{params['type']}/#{params['name']}"
        )
      end

      post '/:type/:name' do
        halt unless params['type'].eql?('exploit') || params['type'].eql?('auxiliary')
        mod = load_module(params['type'], params['name'])
        halt 404 if mod.nil?

        params['options'].each do |opt|
          mod.set_option_value(opt['name'], opt['value'])
        end

        if params['payload']
          mod.payload = load_payload(params['payload']['name'])
          params['payload']['options'].each do |opt|
            mod.payload.set_option_value(opt['name'], opt['value'])
          end
        end

        listener = Class.new do
          def initialize
            self.events = []
          end

          def on_event_emitted(event)
            events.push(event)
          end

          attr_accessor :events
        end.new

        Thread.new do
          mod.event_emitter.subscribe(listener)
          mod.run
        end

        json 'success' => 'true'
      end
    end
  end
end
